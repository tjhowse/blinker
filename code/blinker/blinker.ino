// uint8_t const sequence[] = {170, 34, 234, 46, 163, 187, 128, 174, 139, 163, 187, 142, 224, 56, 170, 32, 42, 142, 238, 46, 226, 162, 2, 186, 46, 59, 138, 46, 163, 174, 224, 56, 186, 46, 42, 226, 138, 128, 238, 40, 235, 162, 168, 139, 168, 186, 136, 11, 139, 168, 142, 174, 2, 227, 163, 168, 10, 139, 142, 224};
// uint8_t const sequence[] = {187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 11, 186, 46, 46, 138, 42, 2, 238, 139, 139, 162, 138, 128, 187, 162, 226, 232, 162, 160, 46, 232, 184, 186, 40, 168, 0};
uint8_t const sequence[] = {21, 21, 80, 1};
uint16_t const sequence_length = 32;

// http://www.technoblogy.com/show?1YQY

uint16_t volatile counter = 0;

#include <avr/wdt.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>

// // TODO Remove this.
void delay (int millis) {
  for (volatile unsigned int i = 34*millis; i>0; i--);
}

void led_off() {
  PORTB = 0b0100;
}

void led_on() {
  PORTB = 0b0000;
}

void setup() {
  // Power saving measures:
  // Disable ADC:
  ADCSRA = 0;
  // Shut down ADC and timer0
  PRR = 0b11;

  // Setup IO:
  DDRB = 0b0100; // PB2 as an output
  led_on();
  sei();

  // This tells the watchdog timer to fire every 250ms.
  // When it fires we will wake from sleep into the WDT_vect ISR.
  // wdt_enable(WDTO_250MS);
  // wdt_enable(WDTO_8S);
  // wdt_enable(WDTO_4S);
  // This should set interrupt mode on the watchdog timer - no reset.
  // wdt_disable();
  // Clear WDE
  // RSTFLR &= ~(1<<WDRF);
  // WDTCSR &= ~(1<<WDE);
  // Set WDIE
  // WDTCSR |= (1<<WDIE);
  // WDTCSR |= (1<<WDIE | 1<<WDE);
  // WDTCSR |= (1<<WDIE | 1<<WDE);
  // CCP = 0xD8; // Magic number to enable change of a protected I/O register.
  // sleep();
}

void sleep() {
  // delay(2000);
  // return;
  // set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  wdt_enable(WDTO_4S);
  WDTCSR |= (1<<WDIE | 1<<WDE);
  set_sleep_mode(SLEEP_MODE_IDLE);
  sleep_enable();
  sleep_cpu();
}

void blink() {
  if (sequence[counter>>3] & (0x01 << counter%8)) {
    led_off();
  } else {
    led_on();
  }
  counter = (counter + 1)%sequence_length;
}

ISR(WDT_vect) {
  RSTFLR &= ~(1<<WDRF);
  WDTCSR &= ~(1<<WDE);
  sleep_disable();
  // wdt_reset();
  // wdt_disable();
  // RSTFLR &= ~(1<<WDRF);
  // WDTCSR &= ~(1<<WDE);
  // led_off();
}
void loop() {
  // wdt_reset();
  led_off();
  sleep();
  // wdt_reset();
  led_on();
  sleep();
}
//   sleep_disable();
// // ISR(0x9) {
//   // Clear WDE. This should prevent a reboot.
//   // RSTFLR &= ~(1<<WDRF);
//   // WDTCSR &= ~(1<<WDE);
//   // while (1) {
//   //   led_off();
//   //   delay(500);
//   //   wdt_reset();
//   //   led_on();
//   //   delay(500);
//   //   wdt_reset();
//   // }
//   // wdt_reset();
//   wdt_disable();
//   // if (RSTFLR & (1<<WDRF)) {
//   //   // Reset was caused by the watchdog timer.
//   //   for (int i = 0; i < 10; i++) {
//   //     led_off();
//   //     delay(100);
//   //     led_on();
//   //     delay(100);
//   //   }
//   // }
//   // wdt_enable(WDTO_8S);
//   led_off();
//   // if (WDTCSR & 1<<WDE) {
//   //   led_off();
//   // } else {
//   //   led_on();
//   // }
//   // WDTCSR |= 1<<WDIE;
//   // If we don't do something here, feed the watchdog maybe? The system will reset
//   // after this vector is executed.
//   // wdt_reset();

//   // WDTCSR |= 1<<WDIE;
//   // RSTFLR &= ~(1<<WDRF);
//   // WDTCSR &= ~(1<<WDE);

//   // blink();
//   // sleep();
// }
